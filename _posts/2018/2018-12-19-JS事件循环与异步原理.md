---
title: 'JS事件循环与异步原理'
date: 2018-12-19
layout: post
tags:
    - JS
    - Javascript
    - 编程语言
    - 异步
    - 多线程
    - 并发
    - 并行
---

> 说好的不学习前端知识居然食言了！不但学了，而且还把JS和HTML+CSS都接触了一遍！不过目前还没有把后端的PHP与SQL学习一遍，主要原因是目前还没有自己的服务器……这篇文章表面上看似是以概述JS中的异步机制为主，但实际上已经把现代操作系统的部分设计原理初步概述了一下。

众所周知JS引擎是**单线程**的，如何实现的异步？实际上每一个**异步事件**产生后它会放入**事件队列等待处理**。何时才会处理它，这是在**主线程中的事件被处理完后**才会从事件队列中逐个取出进行处理。什么是事件？请参考下面的“事件与微任务和宏任务的关系”

需要注意的是JS虽然说是单线程的，但**浏览器是多线程**的。**事件队列的处理对象并非一定是主线程**，而是分配给**浏览器去执行**的。不过具体的异步实现方法是由浏览器来决定的，**多线程只是异步的一种实现方法**。你也可以使用一个线程通过**并行**实现**异步**操作。

## 异步，线程，并行，并发之间是什么关系？##

这个坑有点大，简单的说最早的计算机是**实时**，也就说你输入一个数以后系统会**立即**给出答案。看似很好是不是？但如果你想实现在你输入这个数的**同时**听听音乐这样的实时系统就无法实现了。解决方法是将**任务切片**，分成对个更小的任务，系统在**任务切片**中来回切换从而实现多任务。这也就是**分时**。

当多任务实现以后我们编写的程序终于能够实现**双开工**了。但很快我们就不满足于多任务了——我们**无法同时在听歌查时看歌曲的信息或者歌词**。这时聪明的开发者又想到了既然任务能切片，那么我们就把切片后的**任务再切片**吧，于是我们就有了**进程**。以此类推，进程出现以后我们又遇到进程创建消耗太大的问题，于是我们有了新的**轻量级进程LWP**。LWP相当于是线程，只是与我们常说的线程有点区别。**LWP是由父进程创建**的，多个LWP是**共享父线程的资源**的。

再来讲讲**并行**与**并发**。**两者都属于异步的一种实现**，并行的英语写法是parallel(平行)，而并发则是concurrent(同时)。**并发**指的是逻辑上的两处相同执行单位同时执行，但**不强调“同时(发生和执行)”**，而**并行**指的是物理上两处相同的执行单位同时执行，**强调的是“同时(发生和执行)”**。换句话说你可以把**并行**当做**是并发的子集**。

总的来说：**异步** > **并发** > **并行** > **线程**。**同步**即**实时任务**，反之**异步**则就是**分时任务**。它们各自都是为了**实现异步操作**，在JS中的异步操作与此类似。到这里你也应该明白了为什么JS只有**一个线程也能实现异步**了吧(同理单核CPU多线程也一样)。

(突然想开个新坑，扩展我的cks32指令集)

## 为什么多线程快？##
说到多线程我知道很多人第一反应就是“**快！**”。但事实上真得如此吗？这个问题我自己也曾想过，不过并没有这一篇博客写的详细。我将以下面几个角度来回答这一问题。

- **任务机制决定**  
最直观的感受应该是在下载文件时，如将一个100MB的文件分割为8个小块，交由8个线程分别下载，每个线程只需下载12.5M即可。但这与使用一个线程下载100M有什么区别吗？答案是有的。**传输协议如TCP在设计之初为了给更多的用户使用，对单个用户的传输进行了限制**，想跳出这个限制那么你就得使用多线程去下载。

- **时间占用决定**  
这个就很好理解了。我们把系统每分钟做的事想象成一个饼图，当只有两个单线程任务时两个任务的占比是1:1，也就是各自占50%，但当
其中一个任务是双线程时任务占比就变成了1:2或者是2:1，这样看的话当然是多线程要快一些啦XD。但需要注意的是**大部分情况下CPU的速度是足够处理当前任务的**，因此没有必要为了提速再开启一个线程。相反**多线程会造成CPU在几个线程之间切换，造成不必要的消耗**，造成影响性能的后果。

- **CPU核心数决定**  
为保证执行的正确性，**单线程任务通常会被分配在一个核心上**，所以无法保证完全发挥出CPU的全部性能。所以这时我们就需要**使用多线程来调度多个CPU**同时去完成一个任务，以此达到多线程提速的效果。这也是为什么你会看到在某些安卓项目编译时会叫你加上`make -j <CPU核心数>`的原因所在。至于为什么有人推荐使用`make -j <两倍CPU核心数>`，我想可能也与上面第一点类似，系统在某些层面上限制了用户吧……

## JS中对异步事件的处理方式 ##
JS首先会检查调用的具体类型，如果是异步类型则**加入事件队列**，否则直接通过主线程直接执行。**只有微事件才会实现异步执行**，这与JS中的事件循环(event-loop)对事件处理方式有关。

### JS中异步事件的分类与事件循环 ###
JS中的异步按照优先级又可以分为两类：**宏任务**(macrotask)和**微任务**(microtask)

以下事件属于宏任务：
- `setInterval()`
- `setTimeout()`

以下事件属于微任务
- `new Promise()`
- `new MutaionObserver()`

> 当**宏任务(包括主线程)执行完毕**时会立刻**处理所有微任务**队列中的事件(没有则跳过)，然后再去**执行一个宏任务**队列中的事件……**一直重复以上(宏任务->微任务->宏…)过程直到清空事件队列**。这样一个过程就叫做**事件循环**。任何情况下**单独的一次事件循环中微任务永远在宏任务(不包括主线程)之前执行**。

实例：
```js
setTimeout(function() { // 宏任务
  setTimeout(function() {
    console.log(1); // 宏任务中的宏任务1中的主线程
  });

  console.log(2); // 宏任务中的主线程

  Promise.resolve().then(function() {
    console.log(3); // 宏任务中的微任务1中的主线程
  });

  Promise.resolve().then(function() {
    console.log(4); // 宏任务中的微任务2中的主线程
  });

  setTimeout(function() {
    console.log(5); // 宏任务中的宏任务2中的主线程
  })
});

console.log(6); // 主线程

Promise.resolve().then(function() {
  console.log(7); // 微任务中的主线程
});

// 输出 6 7 2 3 4 1 5
```

> 这篇博客其实很早就打算发布了，但是我自己搞混了一个概念：即当相同的两个事件发生时，如`setTiemout 1`事件和`setTimeout 2`事件同时被加入到事件队列里时，那么会不会造成事件异常？后来我才发现因为我没有仔细的按照流程走一遍(也怪没人画这个图QAQ)，忘记了其实当两个事件同时触发时只有一个事件被处理，所以`setTimeout 1`事件中如果再次触发一个`setTimeout 3`事件，那么他早在`setTimeout 2`之前就被处理了。就好比是函数调用一样，f1传入f3回调，然后f3会在f2前输出也不足为奇了吧……

### 事件与宏任务和微任务的关系 ###
首先我们需要了解JS是一门**事件驱动**的语言。**异步操作**的直接结果会**产生一个事件**加入事件队列，所以本质上**异步操作就是一个事件**。JS**默认提供的事件会对指定的元素广播**的，并递归地执行指定的元素**所有的的监听函数**。当事件监听函数监听到**对应的广播事件**则会执行对应的函数。

## 异步实现顺序执行 ##
异步的好处是我们可以**同时运行多个任务**，但这就引发了另一个问题：**异步**如何**实现顺序执行**？异步事件会在执行时通过任务切片后异步执行。那么我们有什么方法实现在一个异步函数完成以后再执行一个新的函数呢？这里我们就需要用到**回调函数**了。

回调函数这里就不做过多的介绍了，我们更侧重于如何去使用它。当异步事件执行多个函数被切片时，被作为参数传入的**回调函数并非直接参与运行，所以没有被切片**。所以我们可以利用这一点实现顺序执行。

一个简单的异步实例
```js
setTimeout(() => {
    console.log("I am here!");
}, 0);
console.log("Hello!");
```
之前提到了宏任务始终是最后执行的，所以上面的代码输出结果应该是从第四行开始，然后才是第一行的回调。结果为：
```txt
Hello!
I am here!
```

宏任务和微任务的混用：
```js
setTimeout(() => {
    console.log(1)
});
setTimeout(() => {
    console.log(2)
});
Promise.resolve().then(() => {
    console.log(3)
});
console.log(4);

// 输出：4 3 2 1
```

实现一个可读性高一些的回调
```js
function Runthen(onSuccess, onFailed) {
    try {
        onSuccess();
    } catch (e) {
        if (typeof(onFailed) === "function") {
            onFailed(e);
        } else {
            console.error(e);
        }
    }

    return {
        then: Runthen,
        end: function() {}
    }
}

Runthen(() => {
    console.log("Hello x1!");
})
.then(() => {
    console.log("Hello x2!");
})
.then(() => {
    console.log("Hello x3!");
})
.end();
```

## 题外话 ##

最近修改RPGMV的代码里遇到了一个问题：事件触发后不能及时被处理，导致我的一些修改无效。代码如下：  
```js
// 事件模拟
Input._fireKeyDown = function(keyname) {
    document.dispatchEvent(new KeyboardEvent('keydown', {
        key: keyname,
        keyCode: this.nameMapper[keyname],
    }));
}

Input._fireKeyUp = function(keyname) {
    document.dispatchEvent(new KeyboardEvent('keyup', {
        key: keyname,
        keyCode: this.nameMapper[keyname],
    }));
}

Input.fireKey = function(keyname) {
    this._fireKeyDown(keyname);
    // Ensure that keydown has been processed.
    setTimeout((function() {
        this._fireKeyUp(keyname);
    }).bind(this), 0);
}
// 事件监听
document.addEventListener('keydown', function(event) {
    console.log("Key Down: " + event.key);
});

document.addEventListener('keyup', function(event) {
    console.log("Key Up: " + event.key);
});
```
可能因为pixijs引擎的原因，在我模拟按键事件的时候如果keydown和keyup**同时触发**，两个事件会**被忽略掉**(或者说没被处理)，但奇怪的是是件监听函数**能够监听到**两个事件的触发。所以我在触发keyup时套了一层setTimeout使当前微任务都被执行完毕后再执行。当然我还得花点时间消化消化。

## 小结 ##
1. JS是一门事件驱动的编程语言。
2. 微任务始终优先于宏任务(除主线程)执行。
3. 异步操作并非只有多线程能够实现。
4. 多线程并非是最效率的选择方案。
