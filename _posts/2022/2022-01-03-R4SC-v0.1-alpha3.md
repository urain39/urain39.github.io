---
title: '复古4位计算机 R4SC 的设计'
date: 2022-01-03
layout: post
tags:
    - 计算机组成原理
    - CPU
    - 4位机
---

> 设计 R4SC 算是对我之前学习计算机组成原理的一个小考核。
> 此外也是为了填上我之前没能设计完的诸多 8-bit 机的天坑。

基本信息
=======

- 原作者：urain39@qq.com
- 版本号：v0.1-alpha3
- 项目名：Rusty 4-bit Simplified Computer (R4SC)
- 更新日：2022.01.02

> v0.1-alpha3 改动列表
> - 移除关于哈佛结构错误的描述
> - 修正汇编风格章节中的错误
> - 添加 JMP.CF、JMP.NE 指令
>  
> v0.1-alpha2 改动列表
> - 移除 SP 寄存器、JSR 和 JRT 指令
> - 更改 way0、way1 分别为 $A+$B 和 $C+$D
> - 增加 $C0、$C1 作为中断内容寄存器
> - 更改标准中断表以支持 $C0、$C1

以下只是 R4SC 的大致设计概括，完整版估计还需要一些时间补全。

----------------------------------------------------

R4SC 属于改进型哈佛结构计算机。其由 3+16 个寄存器、16 种共
13+2+2+8+8 条指令组成。除指令读取外，其本身无法访问外部内存。
你只能操作其 16 个通用寄存器代替。

R4SC 与哈佛结构最大的不同在于：R4SC 并不以指令区分寻址模式，
而是以 AF 标志位决定。这样设计的好处很明显，我们相当于比原来
多了近一倍的指令。

当然缺点也很明显，编程难度会有所提升。主要是频繁切换 AF 位会
导致代码体积膨胀；但不切换又很难实现一些逻辑。

指令格式
=======

每条指令为固定长度 8-bit，结构如下图：

| 0 ~ 3 | 4 ~ 7 |
|:-----:|:-----:|
|OP     |ARG    |

---------------------------------------------------------

因为 SC 中的 M板 最小单元是 4-bit，所以你可以通过两个 M板 实现
储存 256 字节的程序。其中第一块用于存放指令，第二块用于存放指令的
参数。

全局标志位
=========

|名称    |描述   |
|:-----:|:-----:|
|AF     |参数标志位|
|CF     |进位标志位|
|SF     |符号标志位|
|ZF     |零标志位|

----------------------------------

注：全局标志位包含在下面的 PS 寄存器中。

核心寄存器
=========

|名称    |描述                |
|:-----:|:------------------:|
|PC     |程序计数器（8-bit）   |
|PS     |程序状态寄存器（4-bit）|
|AC     |累加器（4-bit）      |

通用寄存器
=========

|名称    |描述              |
|:-----:|:----------------:|
|$0 ~ $7|可自增寄存器（$In）  |
|$8 ~ $B|普通寄存器（$Nn）    |
| $A+$B |临时地址寄存器1（$A0）|
| $C+$D |临时地址寄存器2（$A1）|
|  $E   |中断内容寄存器1 ($C0)|
|  $F   |中断内容寄存器2 ($C1)|

-------------------------------

补充：
1. $0 不是 累加器 AC
2. $n 表示任意寄存器
3. $A0、$A1 也叫做 way0、way1

指令详解
=======

R4SC 总共有 16 条内部指令，每条指令最多有 2 种寻址模式。
其中指令的寻址方式由全局标志位 AF 位决定。当标志位处于不同
状态时，同一条指令的参数的含义是不一样的。

如当`AF=0`时，LDA 会将 ARG 位当作**立即数**解析；当`AF=1`
时，LDA 会将 ARG 位当作**寄存器**解析。

|指令（AF=0）|符号描述       |
|:---------:|:------------:|
|SET.flg val|（注解1）      |
|LDA val    |val -> AC      |
|STA $n     |AC -> $n       |
|AND val    |AC & val -> AC  |
|ORA val    |AC \| val -> AC |
|NOT val    |~val -> AC     |
|EOR val    |AC ^ val -> AC  |
|LSL val    |AC << val -> AC |
|LSR val    |AC >> val -> AC |
|ASR val    |AC >>> val -> AC|
|ADC val    |AC + val -> AC  |
|SBC val    |AC - val -> AC  |
|INC.mrk $In|（注解2）         |
|CMP val    |（注解3）         |
|JMP.typ way|（注解4）         |
|INT irq    |（详见 标准中断） |

-------------------------------

|指令（AF=1）|符号描述       |
|:---------:|:------------:|
|LDA $n    |$n -> AC      |
|AND $n    |AC & $n -> AC  |
|ORA $n    |AC \| $n -> AC |
|NOT $n    |~$n -> AC     |
|EOR $n    |AC ^ $n -> AC  |
|LSL $n    |AC << $n -> AC |
|LSR $n    |AC >> $n -> AC |
|ASR $n    |AC >>> $n -> AC|
|ADC $n    |AC + $n -> AC  |
|SBC $n    |AC - $n -> AC  |
|CMP $n    |（注解3）         |

- 注解1：SET.flg 指令用于设置标志位，由以下 2 条指令组成
    - SET.AF val    设置 AF=val
    - SET.CF val    设置 CF=val
- 注解2：INC 指令用于自增或自减，由以下 2 条指令组成
    - INC $In         将 $In 中的值加上 1
    - INC.NEG $In     将 $In 中的值减去 1
- 注解3：将累加器 AC 中的值与 val（或 $n）进行比较，并更改 PS 寄存器
- 注解4：JMP 指令用于跟随 PS 状态位跳转，由以下 8 条指令组成
    - JMP way      无条件跳转到 ADDR(way)
    - JMP.CF way   当 CF 为 1 时跳转到 ADDR(way)
    - JMP.LT way   当 CF 为 1，SF 为 1 时跳转到 ADDR(way)
    - JMP.LE way   当 CF 为 1，SF 为 1 时；或者当 ZF 为 0 时跳转到 ADDR(way)
    - JMP.EQ way   当 ZF 为 0 时跳转到 ADDR(way)
    - JMP.GE way   当 CF 为 0，SF 为 0 时；或者当 ZF 为 0 时跳转到 ADDR(way)
    - JMP.GT way   当 CF 为 0，SF 为 0 时跳转到 ADDR(way)
    - JMP.NE way   当 ZF 为 1 时跳转到 ADDR(way)


-----------------------------------

补充：
1. 不是所有的指令都会受到 AF 标志位影响
2. 所有对累加器 AC 更改的指令都会更新 SF 和 ZF 位
3. ADC 和 SBC 执行完后会更改 CF 标志位
4. ADDR(way) 表示将 way 作为地址使用

标准中断
=======

|中断   |文字描述    |
|:-----:|:--------:|
|INT 0x0|$C0 -> $i0|
|INT 0x1|$C1 -> $i0|
|INT 0x2|$i0 -> $C0|
|INT 0x3|$i0 -> $C1|
|INT 0x4|保留1      |
|INT 0x5|保留2      |
|INT 0x6|暂停       |
|INT 0x7|关机       |
|INT 0x8|用户1      |
|...    |...       |
|INT 0xF|用户8      |

-----------------------

补充：
1. $i0 为默认中断接口

汇编风格
=======

C 语言源码：
```c
for (int i = 0; i < 16; i++);
```

等价汇编代码：
```asm
; 设置跳转点 LOOP
SET.AF 0      ; 切换到立即寻址
LDA >LOOP     ; 高地址
STA >WAY0
LDA <LOOP     ; 低地址
STA <WAY0

; 设置跳转点 LOOP.END
SET.AF 0      ; 切换到立即寻址
LDA >LOOP.END ; 高地址
STA >WAY1
LDA <LOOP.END ; 低地址
STA <WAY1

; 初始化
SET.CF 0        ; 清除进位标志
LDA #$0

; 循环体
LOOP:
    JMP.CF WAY1 ; 满 16 后跳转到 LOOP.END
    ADC #$1
    JMP WAY0
LOOP.END:
SET.CF 0
```

--------------------------------------------------

alpha4 考虑合并 $In 和 $An，这样对段控制可能会容易很多。
