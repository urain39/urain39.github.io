---
title: '再谈JS事件循环'
date: 2019-02-30
layout: post
tags:
    - JS
    - Javascript
    - Event Loop
    - 异步
    - 宏任务
    - 微任务
    - 编程语言
    - 事件循环
---

> 这几天费尽心思想写一个可以实现同步的队列，用于将爬虫的流程同步执行(因为如果同一时间的并发过大的话容易被服务器拒绝)，所以特地研究了一下异步转同步的方法。(不过最终因为设计过于复杂而放弃了，有时间再看看async和await)

## 异步和回调的关系
之前我搞混了这个概念，即我认为回调即异步任务其本身。实际上这样理解是不正确的，异步任务中异步执行的**不包含回调**。当异步任务产生时异步会被放在**任务表**，而回调在异步任务**执行完毕后**才放入**任务队列**。

如下面这个经典的实例中
```js
setTimeout(function () {
  console.log("After 1000ms.");
}, 1000);
```
被异步执行的任务是`setTimeout`本身，而回调则是中间的`function`部分。执行顺序为 `setTimeout` -> `function`。

在JS中有至少两个与异步相关的队列(这里不谈微任务)。一个叫做**事件表**(Event Table)，另一个叫做**任务队列**(Task Queue)。前者是用于存放**产生的**异步任务，即表示需要**处理的**任务队列；后者则是存放**处理完毕后的**结果，即带有异步处理结果需要同步**执行回调的**队列。关于为什么这样设计可以参考下面。

## 事件的响应与处理
可能很多人都听说过JS是**单线程**的，但实际上真的是这样吗？并非如此。如果JS是单线程的，那么它**不可能实现**在执行异步任务时**响应新的任务**。那么为什么说JS是单线程的呢？其实JS的单线程指的是**用户编写的代码**一定是以单线程形式执行的，而并不是说它在**实现上**是单线程的。

既然前面已经谈到了事件表的概念，那么我们在这里就能更容易的去理解事件的处理机制。当事件**被触发以后**会被放入事件表，协调线程依会次将事件**分配给闲置的线程**执行，**处理完毕后**才会将结果和回调放入任务队列。而主线程会**循环的检测任务队列**是否为空，如果不为空则取出回调执行。这个循环过程我们一般叫做Event Loop，即**事件循环**。

当任务**被分配出去后**实际上是以**多线程**执行的，所以说JS无法实现多线程倒是有些**太绝对了**。不过貌似现在确实有新的机制可以让JS在同步执行时也能有多线程优化，不过我个人认为在JS强大的异步机制下，线程依然是不必要的。

## 本文小结
- 回调并不是异步执行的
- 事件触发后会被加入任务表
- JS实现上并不一定是单线程的
- 异步队列可分为任务表和任务队列
- 异步被处理后会将回调放入任务队列

